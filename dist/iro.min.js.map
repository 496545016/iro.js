{"version":3,"sources":["webpack:///iro.min.js","webpack:///webpack/bootstrap d72311c9d75c008c8634","webpack:///./util/dom.js","webpack:///./colorModels/rgb.js","webpack:///./modules/color.js","webpack:///./modules/stylesheet.js","webpack:///./colorModels/hsl.js","webpack:///./colorModels/hslString.js","webpack:///./ui/gradient.js","webpack:///./ui/marker.js","webpack:///./modules/colorPicker.js","webpack:///./colorModels/hexString.js","webpack:///./colorModels/rgbString.js","webpack:///./iro.js","webpack:///./ui/slider.js","webpack:///./ui/wheel.js"],"names":["iro","modules","__webpack_require__","moduleId","installedModules","exports","module","i","l","call","m","c","value","d","name","getter","o","Object","defineProperty","configurable","enumerable","get","n","__esModule","object","property","prototype","hasOwnProperty","p","s","iterateList","list","callback","forEach","doc","document","$","selector","querySelector","create","tagName","nameSpaceType","createElementNS","createElement","append","parent","child","appendChild","appendNew","attrs","this","setAttr","attr","el","attrName","getAttribute","setAttribute","listen","eventList","eventName","addEventListener","unlisten","removeEventListener","whenReady","_this","readyState","stateChange","e","round","Math","fromHsv","hsv","r","g","b","f","q","t","h","v","floor","toHsv","rgb","hue","max","min","delta","_interopRequireDefault","obj","default","_hsl","_hsl2","_rgb","_rgb2","_hslString","_hslString2","_rgbString","_rgbString2","_hexString","_hexString2","colorModels","color","str","_onChange","_value","undefined","register","set","model","fromString","descriptor","watch","callImmediately","forceUpdate","unwatch","newValue","changes","oldValue","channel","test","rgbString","hslString","hexString","_dom","_dom2","stylesheet","overrides","style","head","createTextNode","sheet","rules","cssRules","map","on","enable","disabled","off","disable","setRule","replace","$1","toLowerCase","setProperty","index","length","declaration","insertRule","addRule","getCss","ret","ruleSet","getPropertyValue","getCssText","push","cssText","join","hsl","a","parsed","match","parseInt","addColorStops","gradient","colorStops","stop","addColorStop","linear","ctx","x1","y1","x2","y2","createLinearGradient","radial","x","y","createRadialGradient","marker","svg","opts","_el","ring","cy","cx","move","transform","_wheel","_wheel2","_slider","_slider2","_color","_color2","_stylesheet","_stylesheet2","activeColorWheel","_mouseMove","preventDefault","emit","_mouseTarget","colorWheel","_events","css","styles","width","height","pxRatio","devicePixelRatio","viewBox","canvas","getContext","scale","padding","borderWidth","markerRadius","sliderMargin","sliderHeight","bodyWidth","wheelRadius","leftMargin","borderStyles","w","borderColor","ui","cX","cY","rMax","border","sliderType","_update","bind","_mouseDown","eventType","events","splice","indexOf","data","_getLocalPoint","point","touches","changedTouches","rect","getBoundingClientRect","clientX","left","clientY","top","_handleInput","input","uiElement","checkHit","update","properties","prop","useShorthand","divider","bitLength","strLength","int","toString","Array","hex","isShorthand","bitMask","multiplier","_colorPicker","_colorPicker2","Color","ColorPicker","Stylesheet","ColorWheel","_gradient","_gradient2","_marker","_marker2","slider","_ctx","range","type","_opts","radius","rx","ry","draw","clearRect","beginPath","moveTo","arcTo","closePath","fill","0","1","fillStyle","percent","dist","PI","pow","sqrt","abs","wheel","lineWidth","sliceAngle","sliceStart","strokeStyle","arc","stroke","fillRect","hueAngle","cos","sin","rangeMax","angle","atan2","dx","dy"],"mappings":"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","file":"iro.min.js","sourcesContent":["/*!\n * iro.js\n * ----------------\n * Author: James Daniel (github.com/jaames | rakujira.jp)\n * Last updated: Sat Aug 19 2017\n */\nvar iro =\n/******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId]) {\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/ \t\t}\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\ti: moduleId,\n/******/ \t\t\tl: false,\n/******/ \t\t\texports: {}\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.l = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// identity function for calling harmony imports with the correct context\n/******/ \t__webpack_require__.i = function(value) { return value; };\n/******/\n/******/ \t// define getter function for harmony exports\n/******/ \t__webpack_require__.d = function(exports, name, getter) {\n/******/ \t\tif(!__webpack_require__.o(exports, name)) {\n/******/ \t\t\tObject.defineProperty(exports, name, {\n/******/ \t\t\t\tconfigurable: false,\n/******/ \t\t\t\tenumerable: true,\n/******/ \t\t\t\tget: getter\n/******/ \t\t\t});\n/******/ \t\t}\n/******/ \t};\n/******/\n/******/ \t// getDefaultExport function for compatibility with non-harmony modules\n/******/ \t__webpack_require__.n = function(module) {\n/******/ \t\tvar getter = module && module.__esModule ?\n/******/ \t\t\tfunction getDefault() { return module['default']; } :\n/******/ \t\t\tfunction getModuleExports() { return module; };\n/******/ \t\t__webpack_require__.d(getter, 'a', getter);\n/******/ \t\treturn getter;\n/******/ \t};\n/******/\n/******/ \t// Object.prototype.hasOwnProperty.call\n/******/ \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"/test\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(__webpack_require__.s = 11);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\n// Quick reference to the document object and some strings since we usethem more than once\nvar doc = document,\n    READYSTATE_COMPLETE = \"complete\",\n    READYSTATE_CHANGE = \"readystatechange\";\n\n/**\n * @desc iterate a list (or create a one-item list from a string), calling callback with each item\n * @param {ArrayOrString} list an array or string, callback will be called for each array item, or once if a string is given\n * @param {Function} callback a function to call for each item, the item will be passed as the first parameter\n * @access private\n*/\nfunction iterateList(list, callback) {\n  list = \"string\" == typeof list ? [list] : list;\n  list.forEach(callback);\n};\n\nmodule.exports = {\n  /**\n   * @desc find a html element that matches a CSS selector\n   * @param {String} selector the CSS selector to be used to target a HTML element\n   * @return {Element} the HTML element that matches the selector given\n  */\n  $: function $(selector) {\n    return doc.querySelector(selector);\n  },\n\n  /**\n   * @desc create a new HTML element\n   * @param {String} tagName the tag type of the element to create\n   * @param {String} nameSpaceType \"SVG\" = svg namespace, leave false for default namespace\n   * @return {Element} the newly created HTML element\n  */\n  create: function create(tagName, nameSpaceType) {\n    return nameSpaceType == \"SVG\" ? doc.createElementNS(\"http://www.w3.org/2000/svg\", tagName) : doc.createElement(tagName);\n  },\n\n  /**\n   * @desc append a child element to an element\n   * @param {Element} parent the parent element to append to\n   * @param {Element} child the child element to append\n   * @return {Element} the child element, now appended to the parent\n  */\n  append: function append(parent, child) {\n    return parent.appendChild(child);\n  },\n\n  appendNew: function appendNew(parent, tagName, attrs, nameSpaceType) {\n    var child = this.create(tagName, nameSpaceType);\n    this.setAttr(child, attrs);\n    return parent.appendChild(child);\n  },\n\n  /**\n   * @desc get an element's attribute by name\n   * @param {Element} el target element\n   * @param {String} attrName the name of the attribute to get\n   * @return {String} the value of the attribute\n  */\n  attr: function attr(el, attrName) {\n    return el.getAttribute(attrName);\n  },\n\n  setAttr: function setAttr(el, attrs) {\n    for (var attrName in attrs || {}) {\n      el.setAttribute(attrName, attrs[attrName]);\n    }\n  },\n\n  /**\n   * @desc listen to one or more events on an element\n   * @param {Element} el target element\n   * @param {ArrayOrString} eventList the events to listen to\n   * @param {Function} callback the event callback function\n  */\n  listen: function listen(el, eventList, callback) {\n    iterateList(eventList, function (eventName) {\n      el.addEventListener(eventName, callback);\n    });\n  },\n\n  /**\n   * @desc remove an event listener on an element\n   * @param {Element} el target element\n   * @param {ArrayOrString} eventList the events to remove\n   * @param {Function} callback the event callback function\n  */\n  unlisten: function unlisten(el, eventList, callback) {\n    iterateList(eventList, function (eventName) {\n      el.removeEventListener(eventName, callback);\n    });\n  },\n\n  /**\n   * @desc call callback when the page document is ready\n   * @param {Function} callback callback function to be called\n  */\n  whenReady: function whenReady(callback) {\n    var _this = this;\n    if (doc.readyState == READYSTATE_COMPLETE) {\n      callback();\n    } else {\n      _this.listen(doc, READYSTATE_CHANGE, function stateChange(e) {\n        if (doc.readyState == READYSTATE_COMPLETE) {\n          callback();\n          _this.unlisten(doc, READYSTATE_CHANGE, stateChange);\n        }\n      });\n    }\n  }\n};\n\n/***/ }),\n/* 1 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar round = Math.round;\n\nmodule.exports = {\n  name: \"rgb\",\n\n  fromHsv: function fromHsv(hsv) {\n    var r, g, b, i, f, p, q, t;\n    var h = hsv.h / 360,\n        s = hsv.s / 100,\n        v = hsv.v / 100;\n    i = Math.floor(h * 6);\n    f = h * 6 - i;\n    p = v * (1 - s);\n    q = v * (1 - f * s);\n    t = v * (1 - (1 - f) * s);\n    switch (i % 6) {\n      case 0:\n        r = v, g = t, b = p;break;\n      case 1:\n        r = q, g = v, b = p;break;\n      case 2:\n        r = p, g = v, b = t;break;\n      case 3:\n        r = p, g = q, b = v;break;\n      case 4:\n        r = t, g = p, b = v;break;\n      case 5:\n        r = v, g = p, b = q;break;\n    }\n    return { r: round(r * 255), g: round(g * 255), b: round(b * 255) };\n  },\n\n  toHsv: function toHsv(rgb) {\n    // Modified from https://github.com/bgrins/TinyColor/blob/master/tinycolor.js#L446\n    var r = rgb.r / 255,\n        g = rgb.g / 255,\n        b = rgb.b / 255;\n    var max = Math.max(r, g, b),\n        min = Math.min(r, g, b),\n        delta = max - min;\n    var hue;\n    switch (max) {\n      case min:\n        hue = 0;\n        break;\n      case r:\n        hue = (g - b) / delta + (g < b ? 6 : 0);\n        break;\n      case g:\n        hue = (b - r) / delta + 2;\n        break;\n      case b:\n        hue = (r - g) / delta + 4;\n        break;\n    }\n    hue /= 6;\n    return {\n      h: round(hue * 360),\n      s: round(max === 0 ? 0 : delta / max * 100),\n      v: round(max * 100)\n    };\n  }\n};\n\n/***/ }),\n/* 2 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar _hsl = __webpack_require__(4);\n\nvar _hsl2 = _interopRequireDefault(_hsl);\n\nvar _rgb = __webpack_require__(1);\n\nvar _rgb2 = _interopRequireDefault(_rgb);\n\nvar _hslString = __webpack_require__(5);\n\nvar _hslString2 = _interopRequireDefault(_hslString);\n\nvar _rgbString = __webpack_require__(10);\n\nvar _rgbString2 = _interopRequireDefault(_rgbString);\n\nvar _hexString = __webpack_require__(9);\n\nvar _hexString2 = _interopRequireDefault(_hexString);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nvar colorModels = [_hsl2.default, _rgb2.default, _hslString2.default, _rgbString2.default, _hexString2.default];\n\n/**\n  @constructor color object\n  @param {String} str (optional) CSS color string to use as the start color for this element\n*/\nvar color = function color(str) {\n  var _this = this;\n\n  if (!(this instanceof color)) return new color(str);\n  // The watch callback function for this color will be stored here\n  this._onChange = false;\n  // The default color value\n  this._value = { h: undefined, s: undefined, v: undefined };\n  this.register(\"hsv\", {\n    get: this.get,\n    set: this.set\n  });\n  // Loop through each external color model and register it\n  colorModels.forEach(function (model) {\n    _this.register(model.name, {\n      set: function set(value) {\n        this.hsv = model.toHsv(value);\n      },\n      get: function get() {\n        return model.fromHsv(this.hsv);\n      }\n    });\n  });\n  if (str) this.fromString(str);\n};\n\ncolor.prototype = {\n\n  /**\n    * @desc Register a new color model on this instance\n    * @param {String} name The name of the color model\n    * @param {Object} descriptor The property descriptor (see https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty#Description)\n  */\n  register: function register(name, descriptor) {\n    Object.defineProperty(this, name, descriptor);\n  },\n\n  /**\n    * @desc Set a callback function that gets called whenever the selected color changes\n    * @param {Function} callback The watch callback\n    * @param {Boolean} callImmediately set to true if you want to call the callback as soon as it is added\n  */\n  watch: function watch(callback, callImmediately) {\n    this._onChange = callback;\n    if (callImmediately) this.forceUpdate();\n  },\n\n  /**\n    * @desc Remove the watch callback\n  */\n  unwatch: function unwatch() {\n    this.watch(false);\n  },\n\n  /**\n    * @desc Force an update\n  */\n  forceUpdate: function forceUpdate() {\n    var value = this._value;\n    this._onChange(value, value, { h: true, s: true, v: true });\n  },\n\n  /**\n    * @desc Set the color from a HSV value\n    * @param {Object} newValue - HSV object\n  */\n  set: function set(newValue) {\n    // Loop through the channels and check if any of them have changed\n    var changes = {};\n    var oldValue = this._value;\n    for (var channel in oldValue) {\n      if (!newValue.hasOwnProperty(channel)) newValue[channel] = oldValue[channel];\n      changes[channel] = !(newValue[channel] == oldValue[channel]);\n    }\n    // Update the old value\n    this._value = newValue;\n    // If the value has changed, call hook callback\n    var callback = this._onChange;\n    if ((changes.h || changes.s || changes.v) && \"function\" == typeof callback) callback(newValue, oldValue, changes);\n  },\n\n  /**\n    * @desc Get the HSV value\n    * @return HSV object\n  */\n  get: function get() {\n    return this._value;\n  },\n\n  /**\n    * @desc Set the color from a CSS string\n    * @param {String} str - HEX, rgb, or hsl color string\n  */\n  fromString: function fromString(str) {\n    if (/^rgb/.test(str)) {\n      this.rgbString = str;\n    } else if (/^hsl/.test(str)) {\n      this.hslString = str;\n    } else if (/^#[0-9A-Fa-f]/.test(str)) {\n      this.hexString = str;\n    }\n  }\n};\n\nmodule.exports = color;\n\n/***/ }),\n/* 3 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar _dom = __webpack_require__(0);\n\nvar _dom2 = _interopRequireDefault(_dom);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nvar doc = document;\n\n/**\n  @constructor stylesheet writer\n  @param {Object} overrides - an object representing the CSS rules that this stylesheet updates\n*/\nvar stylesheet = function stylesheet(overrides) {\n  // Create a new style element\n  var style = _dom2.default.appendNew(doc.head, \"style\", {});\n  // Webkit apparently requires a text node to be inserted into the style element\n  // (according to https://davidwalsh.name/add-rules-stylesheets)\n  _dom2.default.append(style, doc.createTextNode(\"\"));\n  this.style = style;\n  // Create a reference to the style element's CSSStyleSheet object\n  // CSSStyleSheet API: https://developer.mozilla.org/en-US/docs/Web/API/CSSStyleSheet\n  var sheet = style.sheet;\n  this.sheet = sheet;\n  // Get a reference to the sheet's CSSRuleList object\n  // CSSRuleList API: https://developer.mozilla.org/en-US/docs/Web/API/CSSRuleList\n  this.rules = sheet.rules || sheet.cssRules;\n  // We'll store references to all the CSSStyleDeclaration objects that we change here, keyed by the CSS selector they belong to\n  // CSSStyleDeclaration API: https://developer.mozilla.org/en-US/docs/Web/API/CSSStyleDeclaration\n  this.map = {};\n};\n\nstylesheet.prototype = {\n\n  /**\n    * @desc Turns the stylesheet \"on\", allowing the styles to be rendered\n  */\n  on: function on() {\n    this.enable();\n  },\n  enable: function enable() {\n    this.sheet.disabled = false;\n  },\n\n  /**\n    * @desc Turns the stylesheet \"off\", preventing the styles from being rendered\n  */\n  off: function off() {\n    this.disable();\n  },\n  disable: function disable() {\n    this.sheet.disabled = true;\n  },\n\n  /**\n    * @desc Set a specific rule for a given selector\n    * @param {String} selector - the CSS selector for this rule (e.g. \"body\", \".class\", \"#id\")\n    * @param {String} property - the CSS property to set (e.g. \"background-color\", \"font-family\", \"z-index\")\n    * @param {String} value    - the new value for the rule (e.g. \"rgb(255, 255, 255)\", \"Helvetica\", \"99\")\n  */\n  setRule: function setRule(selector, property, value) {\n    var sheet = this.sheet;\n    var rules = sheet.rules || sheet.cssRules;\n    var map = this.map;\n    // Convert property from camelCase to snake-case\n    property = property.replace(/([A-Z])/g, function ($1) {\n      return \"-\" + $1.toLowerCase();\n    });\n    if (!map.hasOwnProperty(selector)) {\n      // If the selector hasn't been used yet we want to insert the rule at the end of the CSSRuleList, so we use its length as the index value\n      var index = rules.length;\n      // Prepare the rule declaration text, since both insertRule and addRule take this format\n      var declaration = property + \": \" + value;\n      // Insert the new rule into the stylesheet\n      try {\n        // Some browsers only support insertRule, others only support addRule, so we have to use both\n        sheet.insertRule(selector + \" {\" + declaration + \";}\", index);\n      } catch (e) {\n        sheet.addRule(selector, declaration, index);\n      } finally {\n        // Because safari is perhaps the worst browser in all of history, we have to remind it to keep the sheet rules up-to-date\n        rules = sheet.rules || sheet.cssRules;\n        // Add our newly inserted rule's CSSStyleDeclaration object to the internal map\n        map[selector] = rules[index].style;\n      }\n    } else {\n      map[selector].setProperty(property, value);\n    }\n  },\n\n  /**\n    * @desc Get an object representing the current css styles\n    * @return {Object} css object\n  */\n  getCss: function getCss() {\n    var map = this.map;\n    var ret = {};\n    for (var selector in map) {\n      var ruleSet = map[selector];\n      ret[selector] = {};\n      for (var i = 0; i < ruleSet.length; i++) {\n        var property = ruleSet[i];\n        ret[selector][property] = ruleSet.getPropertyValue(property);\n      }\n    }\n    return ret;\n  },\n\n  /**\n    * @desc Get the stylesheet text\n    * @return {String} css text\n  */\n  getCssText: function getCssText() {\n    var map = this.map;\n    var ret = [];\n    for (var selector in map) {\n      ret.push(selector.replace(/,\\W/g, \",\\n\") + \" {\\n\\t\" + map[selector].cssText.replace(/;\\W/g, \";\\n\\t\") + \"\\n}\");\n    }\n    return ret.join(\"\\n\");\n  }\n};\n\nmodule.exports = stylesheet;\n\n/***/ }),\n/* 4 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar round = Math.round;\n\nmodule.exports = {\n  name: \"hsl\",\n\n  fromHsv: function fromHsv(hsv) {\n    var s = hsv.s / 100,\n        v = hsv.v / 100;\n    var p = (2 - s) * v;\n    s = s == 0 ? 0 : s * v / (p < 1 ? p : 2 - p);\n    return {\n      h: hsv.h,\n      s: round(s * 100),\n      l: round(p * 50)\n    };\n  },\n\n  toHsv: function toHsv(hsl) {\n    var s = hsl.s / 50,\n        l = hsl.l / 100;\n    s *= l <= 1 ? l : 2 - l;\n    return {\n      h: hsl.h,\n      s: round(2 * s / (l + s) * 100),\n      v: round((l + s) * 100)\n    };\n  }\n};\n\n/***/ }),\n/* 5 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar _hsl = __webpack_require__(4);\n\nvar _hsl2 = _interopRequireDefault(_hsl);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nmodule.exports = {\n  name: \"hslString\",\n\n  fromHsv: function fromHsv(hsv) {\n    var color = _hsl2.default.fromHsv(hsv);\n    return \"hsl\" + (color.a ? \"a\" : \"\") + \"(\" + color.h + \", \" + color.s + \"%, \" + color.l + \"%\" + (color.a ? \", \" + color.a : \"\") + \")\";\n  },\n\n  toHsv: function toHsv(hslString) {\n    var parsed = hslString.match(/(hsla?)\\((\\d+)(?:\\D+?)(\\d+)(?:\\D+?)(\\d+)(?:\\D+?)?([0-9\\.]+?)?\\)/i);\n    return _hsl2.default.toHsv({\n      h: parseInt(parsed[2]),\n      s: parseInt(parsed[3]),\n      l: parseInt(parsed[4])\n    });\n  }\n};\n\n/***/ }),\n/* 6 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nfunction addColorStops(gradient, colorStops) {\n  for (stop in colorStops) {\n    gradient.addColorStop(stop, colorStops[stop]);\n  }\n  return gradient;\n};\n\nmodule.exports = {\n  linear: function linear(ctx, x1, y1, x2, y2, colorStops) {\n    return addColorStops(ctx.createLinearGradient(x1, y1, x2, y1), colorStops);\n  },\n  radial: function radial(ctx, x, y, min, max, colorStops) {\n    return addColorStops(ctx.createRadialGradient(x, y, min, x, y, max), colorStops);\n  }\n};\n\n/***/ }),\n/* 7 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar _dom = __webpack_require__(0);\n\nvar _dom2 = _interopRequireDefault(_dom);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n/**\n  * @constructor marker UI\n  * @param {Object} ctx - canvas 2d context to draw on\n  * @param {Object} opts - options\n*/\nvar marker = function marker(svg, opts) {\n  var _this = this;\n\n  this._el = _dom2.default.appendNew(svg, \"g\", {}, \"SVG\");\n  [[5, \"#000\"], [2, \"#fff\"]].map(function (ring) {\n    _dom2.default.appendNew(_this._el, \"circle\", {\n      r: opts.r,\n      style: \"fill:none;stroke-width:\" + ring[0] + \";stroke:\" + ring[1],\n      cy: 0,\n      cx: 0\n    }, \"SVG\");\n  });\n};\n\nmarker.prototype = {\n  /**\n    * @desc move markerpoint to centerpoint (x, y) and redraw\n    * @param {Number} x - point x coordinate\n    * @param {Number} y - point y coordinate\n  */\n  move: function move(x, y) {\n    _dom2.default.setAttr(this._el, {\n      transform: \"translate(\" + x + \" \" + y + \")\"\n    });\n  }\n};\n\nmodule.exports = marker;\n\n/***/ }),\n/* 8 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar _wheel = __webpack_require__(13);\n\nvar _wheel2 = _interopRequireDefault(_wheel);\n\nvar _slider = __webpack_require__(12);\n\nvar _slider2 = _interopRequireDefault(_slider);\n\nvar _dom = __webpack_require__(0);\n\nvar _dom2 = _interopRequireDefault(_dom);\n\nvar _color = __webpack_require__(2);\n\nvar _color2 = _interopRequireDefault(_color);\n\nvar _stylesheet = __webpack_require__(3);\n\nvar _stylesheet2 = _interopRequireDefault(_stylesheet);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n// When the user starts to interact with a color picker's UI, a referece to that coloPicker will be stored globally\nvar activeColorWheel = false;\n\n// Global mousemove + touchmove event handler\n_dom2.default.listen(document, [\"mousemove\", \"touchmove\"], function (e) {\n  // If there is an active colorWheel, call its mousemove handler\n  if (activeColorWheel) activeColorWheel._mouseMove(e);\n});\n\n// Global mouseup + touchend event handler\n_dom2.default.listen(document, [\"mouseup\", \"touchend\"], function (e) {\n  // If there is an active colorWheel, stop it from handling input and clear the active colorWheel reference\n  if (activeColorWheel) {\n    e.preventDefault();\n    activeColorWheel.emit(\"input:end\");\n    activeColorWheel._mouseTarget = false;\n    activeColorWheel = false;\n  }\n});\n\n/**\n  @constructor color wheel object\n  @param {ElementOrString} el - a DOM element or the CSS selector for a DOM element to use as a container for the UI\n  @param {Object} opts - options for this instance\n*/\nvar colorWheel = function colorWheel(el, opts) {\n  if (!(this instanceof colorWheel)) return new colorWheel(el, opts);\n  // event storage for `on` and `off`\n  this._events = {};\n  this._mouseTarget = false;\n  this._onChange = false;\n  // Create an iroStyleSheet for this colorWheel's CSS overrides\n  this.stylesheet = new _stylesheet2.default();\n  this.css = opts.css || opts.styles || undefined;\n  // Create an iroColor to store this colorWheel's selected color\n  this.color = new _color2.default(opts.color || \"#fff\");\n\n  // Wait for the document to be ready, then init the UI\n  _dom2.default.whenReady(function () {\n    // If `el` is a string, use it to select an Element, else assume it's an element\n    el = \"string\" == typeof el ? _dom2.default.$(el) : el;\n    // Make sure the canvas wrapper is position:relative\n    // This is because we'll be using position:absolute to stack the canvas layers\n    el.style.cssText += \"position:relative\";\n    // Find the width and height for the UI\n    // If not defined in the options, try the HTML width + height attributes of the wrapper, else default to 320\n    var width = opts.width || parseInt(_dom2.default.attr(el, \"width\")) || 320;\n    var height = opts.height || parseInt(_dom2.default.attr(el, \"height\")) || 320;\n    // Create UI layers\n    // To support devices with hidpi screens, we scale the canvas so that it has more pixels, but still has the same size visually\n    // This implementation is based on https://www.html5rocks.com/en/tutorials/canvas/hidpi/\n    var pxRatio = devicePixelRatio || 1;\n    // Create a layer for each name\n    // Create a new canvas and add it to the page\n\n    var svg = _dom2.default.appendNew(el, \"svg\", {\n      viewBox: [0, 0, width, height].join(\" \"),\n      width: width,\n      height: height,\n      style: \"position:absolute;top:0;left:0;\"\n    }, \"SVG\");\n\n    var canvas = _dom2.default.appendNew(el, \"canvas\", {\n      width: width * pxRatio,\n      height: height * pxRatio,\n      style: \"width:\" + width + \"px;height:\" + height + \"px\"\n    });\n\n    var ctx = canvas.getContext(\"2d\");\n    ctx.scale(pxRatio, pxRatio);\n\n    this.el = el;\n    this.canvas = canvas;\n    this.ctx = ctx;\n    this.svg = svg;\n    // Calculate layout variables\n    var padding = opts.padding + 2 || 6,\n        borderWidth = opts.borderWidth || 0,\n        markerRadius = opts.markerRadius || 8,\n        sliderMargin = opts.sliderMargin || 24,\n        sliderHeight = opts.sliderHeight || markerRadius * 2 + padding * 2 + borderWidth * 2,\n        bodyWidth = Math.min(height - sliderHeight - sliderMargin, width),\n        wheelRadius = bodyWidth / 2 - borderWidth,\n        leftMargin = (width - bodyWidth) / 2;\n    var marker = {\n      r: markerRadius\n    };\n    var borderStyles = {\n      w: borderWidth,\n      color: opts.borderColor || \"#fff\"\n    };\n    // Create UI elements\n    this.ui = [new _wheel2.default(ctx, svg, {\n      cX: leftMargin + bodyWidth / 2,\n      cY: bodyWidth / 2,\n      r: wheelRadius,\n      rMax: wheelRadius - (markerRadius + padding),\n      marker: marker,\n      border: borderStyles\n    }), new _slider2.default(ctx, svg, {\n      sliderType: \"v\",\n      x: leftMargin + borderWidth,\n      y: bodyWidth + sliderMargin,\n      w: bodyWidth - borderWidth * 2,\n      h: sliderHeight - borderWidth * 2,\n      r: sliderHeight / 2 - borderWidth,\n      marker: marker,\n      border: borderStyles\n    })];\n    // Whenever the selected color changes, trigger a colorWheel update too\n    this.color.watch(this._update.bind(this), true);\n    // Add handler for mousedown + touchdown events on this element\n    _dom2.default.listen(el, [\"mousedown\", \"touchstart\"], this._mouseDown.bind(this));\n  }.bind(this));\n};\n\ncolorWheel.prototype = {\n  /**\n    * @desc Set a callback function that gets called whenever the selected color changes\n    * @param {Function} callback The watch callback\n    * @param {Boolean} callImmediately set to true if you want to call the callback as soon as it is added\n  */\n  watch: function watch(callback, callImmediately) {\n    this.on(\"color:change\", callback);\n    this._onChange = callback;\n    if (callImmediately) callback(this.color);\n  },\n\n  /**\n    * @desc Remove the watch callback\n  */\n  unwatch: function unwatch() {\n    this.off(\"color:change\", this._onChange);\n  },\n\n  /**\n    * @desc Set a callback function for an event\n    * @param {String} eventType The name of the event to listen to, pass \"*\" to listen to all events\n    * @param {Function} callback The watch callback\n  */\n  on: function on(eventType, callback) {\n    var events = this._events;\n    (events[eventType] || (events[eventType] = [])).push(callback);\n  },\n\n  /**\n    * @desc Remove a callback function for an event added with on()\n    * @param {String} eventType The name of the event\n    * @param {Function} callback The watch callback to remove from the event\n  */\n  off: function off(eventType, callback) {\n    var events = this._events;\n    if (events[eventType]) {\n      events[eventType].splice(events[eventType].indexOf(callback), 1);\n    }\n  },\n\n  /**\n    * @desc Emit an event\n    * @param {String} eventType The name of the event to emit\n    * @param {Object} data data to pass to all the callback functions\n  */\n  emit: function emit(eventType, data) {\n    var events = this._events;\n    (events[eventType] || []).map(function (callback) {\n      callback(data);\n    });\n    (events[\"*\"] || []).map(function (callback) {\n      callback(data);\n    });\n  },\n\n  /**\n    * @desc Get the local-space X and Y pointer position from an input event\n    * @param {Event} e A mouse or touch event\n    * @return {Object} x and y coordinates from the top-left of the UI\n    * @access protected\n  */\n  _getLocalPoint: function _getLocalPoint(e) {\n    // Prevent default event behaviour, like scrolling\n    e.preventDefault();\n    // Detect if the event is a touch event by checking if it has the `touches` property\n    // If it is a touch event, use the first touch input\n    var point = e.touches ? e.changedTouches[0] : e,\n\n    // Get the screen position of the UI\n    rect = this.canvas.getBoundingClientRect();\n    // Convert the screen-space pointer position to local-space\n    return {\n      x: point.clientX - rect.left,\n      y: point.clientY - rect.top\n    };\n  },\n\n  /**\n    * @desc Handle a pointer input at local-space point (x, y)\n    * @param {Event} e A mouse or touch event\n    * @return {Object} x and y coordinates from the top-left of the UI\n    * @access protected\n  */\n  _handleInput: function _handleInput(x, y) {\n    // Use the active UI element to handle translating the input to a change in the color\n    this.color.set(this._mouseTarget.input(x, y));\n  },\n\n  /**\n    * @desc mousedown event handler\n    * @param {Event} e A mouse or touch event\n    * @access protected\n  */\n  _mouseDown: function _mouseDown(e) {\n    var _this = this;\n\n    // Get the local-space position of the mouse input\n    var point = this._getLocalPoint(e),\n        x = point.x,\n        y = point.y;\n\n    // Loop through each UI element and check if the point \"hits\" it\n    this.ui.forEach(function (uiElement) {\n      // If the element is hit, this means the user has clicked the element and is trying to interact with it\n      if (uiElement.checkHit(x, y)) {\n        // Set a reference to this colorWheel instance so that the global event handlers know about it\n        activeColorWheel = _this;\n        // Set an internal reference to the uiElement being interacted with, for other internal event handlers\n        _this._mouseTarget = uiElement;\n        // Emit input start event\n        _this.emit(\"input:start\");\n        // Finally, use the position to update the picked color\n        _this._handleInput(x, y);\n      }\n    });\n  },\n\n  /**\n    * @desc mousemose event handler\n    * @param {Event} e A mouse or touch event\n    * @access protected\n  */\n  _mouseMove: function _mouseMove(e) {\n    // If there is an active colorWheel (set in _mouseDown) then update the input as the user interacts with it\n    if (this == activeColorWheel) {\n      // Get the local-space position of the mouse input\n      var point = this._getLocalPoint(e);\n      // Use the position to update the picker color\n      this._handleInput(point.x, point.y);\n    }\n  },\n\n  /**\n    * @desc update the selected color\n    * @param {Object} newValue - the new HSV values\n    * @param {Object} oldValue - the old HSV values\n    * @param {Object} changes - booleans for each HSV channel: true if the new value is different to the old value, else false\n    * @access protected\n  */\n  _update: function _update(newValue, oldValue, changes) {\n    var color = this.color;\n    var rgb = color.rgbString;\n    var css = this.css;\n    // Loop through each UI element and update it\n    this.ui.forEach(function (uiElement) {\n      uiElement.update(color, changes);\n    });\n    // Update the stylesheet too\n    for (var selector in css) {\n      var properties = css[selector];\n      for (var prop in properties) {\n        this.stylesheet.setRule(selector, prop, rgb);\n      }\n    }\n    // Call the color change event\n    this.emit(\"color:change\", color);\n  }\n};\n\nmodule.exports = colorWheel;\n\n/***/ }),\n/* 9 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar _rgb = __webpack_require__(1);\n\nvar _rgb2 = _interopRequireDefault(_rgb);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nmodule.exports = {\n  name: \"hexString\",\n\n  fromHsv: function fromHsv(hsv) {\n    var color = _rgb2.default.fromHsv(hsv),\n        r = color.r,\n        g = color.g,\n        b = color.b;\n    // If each RGB channel's value is a multiple of 17, we can use HEX shorthand notation\n    var useShorthand = r % 17 == 0 && g % 17 == 0 && b % 17 == 0,\n\n    // If we're using shorthand notation, divide each channel by 17\n    divider = useShorthand ? 17 : 1,\n\n    // bitLength of each channel (for example, F is 4 bits long while FF is 8 bits long)\n    bitLength = useShorthand ? 4 : 8,\n\n    // Target length of the string (ie \"#FFF\" or \"#FFFFFF\")\n    strLength = useShorthand ? 4 : 7,\n\n    // Combine the channels together into a single integer\n    int = r / divider << bitLength * 2 | g / divider << bitLength | b / divider,\n\n    // Convert that integer to a hex string\n    str = int.toString(16);\n    // Add right amount of left-padding\n    return \"#\" + new Array(strLength - str.length).join(\"0\") + str;\n  },\n\n  toHsv: function toHsv(hex) {\n    // Strip any \"#\" characters\n    hex = hex.replace(/#/g, '');\n    // Prefix the hex string with \"0x\" which indicates a number in hex notation, then convert to an integer\n    var int = parseInt(\"0x\" + hex),\n\n    // If the length of the input is only 3, then it is a shorthand hex color\n    isShorthand = hex.length == 3,\n\n    // bitMask for isolating each channel\n    bitMask = isShorthand ? 0xF : 0xFF,\n\n    // bitLength of each channel (for example, F is 4 bits long while FF is 8 bits long)\n    bitLength = isShorthand ? 4 : 8,\n\n    // If we're using shorthand notation, multiply each channel by 17\n    multiplier = isShorthand ? 17 : 1;\n\n    return _rgb2.default.toHsv({\n      r: (int >> bitLength * 2 & bitMask) * multiplier,\n      g: (int >> bitLength & bitMask) * multiplier,\n      b: (int & bitMask) * multiplier\n    });\n  }\n};\n\n/***/ }),\n/* 10 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar _rgb = __webpack_require__(1);\n\nvar _rgb2 = _interopRequireDefault(_rgb);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nmodule.exports = {\n  name: \"rgbString\",\n\n  fromHsv: function fromHsv(hsv) {\n    var color = _rgb2.default.fromHsv(hsv);\n    return \"rgb\" + (color.a ? \"a\" : \"\") + \"(\" + color.r + \", \" + color.g + \", \" + color.b + (color.a ? \", \" + color.a : \"\") + \")\";\n  },\n\n  toHsv: function toHsv(rgbString) {\n    var parsed = rgbString.match(/(rgba?)\\((\\d+)(?:\\D+?)(\\d+)(?:\\D+?)(\\d+)(?:\\D+?)?([0-9\\.]+?)?\\)/i);\n    return _rgb2.default.toHsv({\n      r: parseInt(parsed[2]),\n      g: parseInt(parsed[3]),\n      b: parseInt(parsed[4])\n    });\n  }\n};\n\n/***/ }),\n/* 11 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar _colorPicker = __webpack_require__(8);\n\nvar _colorPicker2 = _interopRequireDefault(_colorPicker);\n\nvar _color = __webpack_require__(2);\n\nvar _color2 = _interopRequireDefault(_color);\n\nvar _stylesheet = __webpack_require__(3);\n\nvar _stylesheet2 = _interopRequireDefault(_stylesheet);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nmodule.exports = {\n  Color: _color2.default,\n  ColorPicker: _colorPicker2.default,\n  Stylesheet: _stylesheet2.default,\n  // for backwards compat\n  ColorWheel: _colorPicker2.default\n};\n\n/***/ }),\n/* 12 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar _gradient = __webpack_require__(6);\n\nvar _gradient2 = _interopRequireDefault(_gradient);\n\nvar _marker = __webpack_require__(7);\n\nvar _marker2 = _interopRequireDefault(_marker);\n\nvar _dom = __webpack_require__(0);\n\nvar _dom2 = _interopRequireDefault(_dom);\n\nvar _hslString = __webpack_require__(5);\n\nvar _hslString2 = _interopRequireDefault(_hslString);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n/**\n  * @constructor slider UI\n*/\nvar slider = function slider(ctx, svg, opts) {\n  this._ctx = ctx;\n  opts.x1 = opts.x;\n  opts.y1 = opts.y;\n  opts.x2 = opts.x + opts.w;\n  opts.y2 = opts.y + opts.h;\n  // \"range\" limits how far the slider's marker can travel, and where it stops and starts along the X axis\n  opts.range = {\n    min: opts.x + opts.r,\n    max: opts.x2 - opts.r,\n    w: opts.w - opts.r * 2\n  };\n  opts.sliderType = opts.sliderType || \"v\";\n  this.type = \"slider\";\n  this.marker = new _marker2.default(svg, opts.marker);\n  this._opts = opts;\n  var borderWidth = opts.border.w;\n  var radius = opts.r + borderWidth / 2;\n  if (borderWidth > 0) {\n    _dom2.default.appendNew(svg, \"rect\", {\n      rx: radius,\n      ry: radius,\n      x: opts.x - borderWidth / 2,\n      y: opts.y - borderWidth / 2,\n      width: opts.w + borderWidth,\n      height: opts.h + borderWidth,\n      style: \"fill:none;stroke-width:\" + borderWidth + \";stroke:\" + opts.border.color\n    }, \"SVG\");\n  }\n};\n\nslider.prototype = {\n  /**\n    * @desc redraw this UI element\n  */\n  draw: function draw(hsv) {\n    var ctx = this._ctx;\n    var opts = this._opts;\n    var x1 = opts.x1,\n        y1 = opts.y1,\n        x2 = opts.x2,\n        y2 = opts.y2,\n        w = opts.w,\n        h = opts.h,\n        r = opts.r;\n\n    // Clear the existing UI\n    ctx.clearRect(x1, y1, w, h);\n\n    // Draw a rounded rect\n    // Modified from http://stackoverflow.com/a/7838871\n    ctx.beginPath();\n    ctx.moveTo(x1 + r, y1);\n    ctx.arcTo(x2, y1, x2, y2, r);\n    ctx.arcTo(x2, y2, x1, y2, r);\n    ctx.arcTo(x1, y2, x1, y1, r);\n    ctx.arcTo(x1, y1, x2, y1, r);\n    ctx.closePath();\n\n    // I plan to have different slider \"types\" in the future\n    // (I'd like to add a transparency slider at some point, for example)\n    var fill;\n\n    // For now the only type is \"V\", meaning this slider adjusts the HSV V channel\n    if (opts.sliderType == \"v\") {\n      fill = _gradient2.default.linear(ctx, x1, y1, x2, y2, {\n        0: \"#000\",\n        1: _hslString2.default.fromHsv({ h: hsv.h, s: hsv.s, v: 100 })\n      });\n    }\n\n    // Draw gradient\n    ctx.fillStyle = fill;\n    ctx.fill();\n  },\n\n  /**\n    * @desc updates this element to represent a new color value\n    * @param {Object} color - an iroColor object with the new color value\n    * @param {Object} changes - an object that gives a boolean for each HSV channel, indicating whether ot not that channel has changed\n  */\n  update: function update(color, changes) {\n    var opts = this._opts;\n    var range = opts.range;\n    var hsv = color.hsv;\n    if (opts.sliderType == \"v\") {\n      if (changes.h || changes.s) {\n        this.draw(hsv);\n      }\n      if (changes.v) {\n        var percent = hsv.v / 100;\n        this.marker.move(range.min + percent * range.w, opts.y1 + opts.h / 2);\n      }\n    }\n  },\n\n  /**\n    * @desc Takes a point at (x, y) and returns HSV values based on this input -- use this to update a color from mouse input\n    * @param {Number} x - point x coordinate\n    * @param {Number} y - point y coordinate\n    * @return {Object} - new HSV color values (some channels may be missing)\n  */\n  input: function input(x, y) {\n    var opts = this._opts;\n    var range = opts.range;\n    var dist = Math.max(Math.min(x, range.max), range.min) - range.min;\n    return {\n      v: Math.round(100 / range.w * dist)\n    };\n  },\n\n  /**\n    * @desc Check if a point at (x, y) is inside this element\n    * @param {Number} x - point x coordinate\n    * @param {Number} y - point y coordinate\n    * @return {Boolean} - true if the point is a \"hit\", else false\n  */\n  checkHit: function checkHit(x, y) {\n    var opts = this._opts;\n    return x > opts.x1 && x < opts.x2 && y > opts.y1 && y < opts.y2;\n  }\n};\n\nmodule.exports = slider;\n\n/***/ }),\n/* 13 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar _gradient = __webpack_require__(6);\n\nvar _gradient2 = _interopRequireDefault(_gradient);\n\nvar _marker = __webpack_require__(7);\n\nvar _marker2 = _interopRequireDefault(_marker);\n\nvar _dom = __webpack_require__(0);\n\nvar _dom2 = _interopRequireDefault(_dom);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n// Quick references to reused math functions\nvar PI = Math.PI,\n    pow = Math.pow,\n    sqrt = Math.sqrt,\n    abs = Math.abs,\n    round = Math.round;\n\n/**\n  * @constructor hue wheel UI\n*/\nvar wheel = function wheel(ctx, svg, opts) {\n  this._ctx = ctx;\n  this._opts = opts;\n  this.type = \"wheel\";\n  this.marker = new _marker2.default(svg, opts.marker);\n  if (borderWidth > 0) {\n    _dom2.default.appendNew(svg, \"circle\", {\n      r: opts.r + opts.border.w / 2,\n      style: \"fill:none;stroke-width:\" + opts.border.w + \";stroke:\" + opts.border.color,\n      cy: opts.cY,\n      cx: opts.cX\n    }, \"SVG\");\n  }\n};\n\nwheel.prototype = {\n\n  /**\n    * @desc redraw this UI element\n    * @param {Number} value - The hsv value component to use when drawing\n  */\n  draw: function draw(value) {\n    var ctx = this._ctx;\n    var opts = this._opts;\n    var x = opts.cX,\n        y = opts.cY,\n        border = opts.border,\n        borderWidth = border.w,\n        radius = opts.r;\n\n    // Clear the area where the wheel will be drawn\n    ctx.clearRect(x - radius - borderWidth, y - radius - borderWidth, radius * 2, radius * 2);\n    ctx.lineWidth = radius;\n\n    // The hue wheel is basically drawn with a series of thin \"pie slices\" - one slice for each hue degree\n    // Here we calculate the angle for each slice, in radians\n    var sliceAngle = 2 * PI / 360;\n\n    // Create a loop to draw each slice\n    for (var hue = 0, sliceStart = 0; hue < 360; hue++, sliceStart += sliceAngle) {\n      // Create a HSL color for the slice using the current hue value\n      ctx.strokeStyle = \"hsl(\" + hue + \",100%,\" + value / 2 + \"%)\";\n      ctx.beginPath();\n      // For whatever reason (maybe a rounding issue?) the slices had a slight gap between them, which caused rendering artifacts\n      // So we make them overlap ever so slightly by adding a tiny value to the slice angle\n      ctx.arc(x, y, radius / 2, sliceStart, sliceStart + sliceAngle + 0.04);\n      ctx.stroke();\n    }\n\n    // Create a radial gradient for \"saturation\"\n    var hslString = \"hsla(0,0%,\" + value + \"%,\";\n    ctx.fillStyle = _gradient2.default.radial(ctx, x, y, 0, opts.rMax, {\n      // The center of the color wheel should be pure white (0% saturation)\n      0: hslString + \"1)\",\n      // It gradially tapers to transparent white (or, visually, 100% saturation color already drawn) at the edge of the wheel\n      1: hslString + \"0)\"\n    });\n    // Draw a rect using the gradient as a fill style\n    ctx.fillRect(x - radius, y - radius, radius * 2, radius * 2);\n  },\n\n  /**\n    * @desc updates this element to represent a new color value\n    * @param {Object} color - an iroColor object with the new color value\n    * @param {Object} changes - an object that gives a boolean for each HSV channel, indicating whether ot not that channel has changed\n  */\n  update: function update(color, changes) {\n    var opts = this._opts;\n    var hsv = color.hsv;\n    // If the V channel has changed, redraw the wheel UI with the new value\n    if (changes.v) {\n      this.draw(hsv.v);\n    }\n    // If the H or S channel has changed, move the marker to the right position\n    if (changes.h || changes.s) {\n      // convert the hue value to radians, since we'll use it as an angle\n      var hueAngle = hsv.h * (PI / 180);\n      // convert the saturation value to a distance between the center of the ring and the edge\n      var dist = hsv.s / 100 * opts.rMax;\n      // Move the marker based on the angle and distance\n      this.marker.move(opts.cX + dist * Math.cos(hueAngle), opts.cY + dist * Math.sin(hueAngle));\n    }\n  },\n\n  /**\n    * @desc Takes a point at (x, y) and returns HSV values based on this input -- use this to update a color from mouse input\n    * @param {Number} x - point x coordinate\n    * @param {Number} y - point y coordinate\n    * @return {Object} - new HSV color values (some channels may be missing)\n  */\n  input: function input(x, y) {\n    var opts = this._opts,\n        cX = opts.cX,\n        cY = opts.cY,\n        radius = opts.r,\n        rangeMax = opts.rMax;\n\n    // Angle in radians, anticlockwise starting at 12 o'clock\n    var angle = Math.atan2(x - cX, y - cY),\n\n    // Calculate the hue by converting the angle to radians, and normalising the angle to 3 o'clock\n    hue = 360 - (round(angle * (180 / PI)) + 270) % 360,\n\n    // Find the point's distance from the center of the wheel\n    // This is used to show the saturation level\n    dist = Math.min(sqrt(pow(cX - x, 2) + pow(cY - y, 2)), rangeMax);\n\n    // Return just the H and S channels, the wheel element doesn't do anything with the L channel\n    return {\n      h: hue,\n      s: round(100 / rangeMax * dist)\n    };\n  },\n\n  /**\n    * @desc Check if a point at (x, y) is inside this element\n    * @param {Number} x - point x coordinate\n    * @param {Number} y - point y coordinate\n    * @return {Boolean} - true if the point is a \"hit\", else false\n  */\n  checkHit: function checkHit(x, y) {\n    var opts = this._opts;\n\n    // Check if the point is within the hue ring by comparing the point's distance from the centre to the ring's radius\n    // If the distance is smaller than the radius, then we have a hit\n    var dx = abs(x - opts.cX),\n        dy = abs(y - opts.cY);\n    return sqrt(dx * dx + dy * dy) < opts.r;\n  }\n};\n\nmodule.exports = wheel;\n\n/***/ })\n/******/ ]);\n\n\n// WEBPACK FOOTER //\n// iro.min.js"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// identity function for calling harmony imports with the correct context\n \t__webpack_require__.i = function(value) { return value; };\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"/test\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 11);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap d72311c9d75c008c8634","// Quick reference to the document object and some strings since we usethem more than once\nconst doc = document,\n      READYSTATE_COMPLETE = \"complete\",\n      READYSTATE_CHANGE = \"readystatechange\";\n\n/**\n * @desc iterate a list (or create a one-item list from a string), calling callback with each item\n * @param {ArrayOrString} list an array or string, callback will be called for each array item, or once if a string is given\n * @param {Function} callback a function to call for each item, the item will be passed as the first parameter\n * @access private\n*/\nfunction iterateList(list, callback) {\n  list = (\"string\" == typeof list) ? [list] : list;\n  list.forEach(callback);\n};\n\nmodule.exports = {\n  /**\n   * @desc find a html element that matches a CSS selector\n   * @param {String} selector the CSS selector to be used to target a HTML element\n   * @return {Element} the HTML element that matches the selector given\n  */\n  $: function (selector) {\n    return doc.querySelector(selector);\n  },\n\n  /**\n   * @desc create a new HTML element\n   * @param {String} tagName the tag type of the element to create\n   * @param {String} nameSpaceType \"SVG\" = svg namespace, leave false for default namespace\n   * @return {Element} the newly created HTML element\n  */\n  create: function (tagName, nameSpaceType) {\n    return nameSpaceType == \"SVG\" ? doc.createElementNS(\"http://www.w3.org/2000/svg\", tagName) : doc.createElement(tagName);\n  },\n\n  /**\n   * @desc append a child element to an element\n   * @param {Element} parent the parent element to append to\n   * @param {Element} child the child element to append\n   * @return {Element} the child element, now appended to the parent\n  */\n  append: function (parent, child) {\n    return parent.appendChild(child);\n  },\n\n  appendNew: function (parent, tagName, attrs, nameSpaceType) {\n    var child = this.create(tagName, nameSpaceType);\n    this.setAttr(child, attrs);\n    return parent.appendChild(child);\n  },\n\n  /**\n   * @desc get an element's attribute by name\n   * @param {Element} el target element\n   * @param {String} attrName the name of the attribute to get\n   * @return {String} the value of the attribute\n  */\n  attr: function (el, attrName) {\n    return el.getAttribute(attrName);\n  },\n\n  setAttr: function (el, attrs) {\n    for (var attrName in (attrs || {})) {\n      el.setAttribute(attrName, attrs[attrName]);\n    }\n  },\n\n  /**\n   * @desc listen to one or more events on an element\n   * @param {Element} el target element\n   * @param {ArrayOrString} eventList the events to listen to\n   * @param {Function} callback the event callback function\n  */\n  listen: function (el, eventList, callback) {\n    iterateList(eventList, function (eventName) {\n      el.addEventListener(eventName, callback);\n    });\n  },\n\n  /**\n   * @desc remove an event listener on an element\n   * @param {Element} el target element\n   * @param {ArrayOrString} eventList the events to remove\n   * @param {Function} callback the event callback function\n  */\n  unlisten: function (el, eventList, callback) {\n    iterateList(eventList, function (eventName) {\n      el.removeEventListener(eventName, callback);\n    });\n  },\n\n  /**\n   * @desc call callback when the page document is ready\n   * @param {Function} callback callback function to be called\n  */\n  whenReady: function (callback) {\n    var _this = this;\n    if (doc.readyState == READYSTATE_COMPLETE) {\n      callback();\n    }\n    else {\n      _this.listen(doc, READYSTATE_CHANGE, function stateChange(e) {\n        if (doc.readyState == READYSTATE_COMPLETE) {\n          callback();\n          _this.unlisten(doc, READYSTATE_CHANGE, stateChange);\n        }\n      });\n    }\n  },\n}\n\n\n\n// WEBPACK FOOTER //\n// ./util/dom.js","var round = Math.round;\n\nmodule.exports = {\n  name: \"rgb\",\n\n  fromHsv: function (hsv) {\n    var r, g, b, i, f, p, q, t;\n    var h = hsv.h/360, s = hsv.s/100, v = hsv.v/100;\n    i = Math.floor(h * 6);\n    f = h * 6 - i;\n    p = v * (1 - s);\n    q = v * (1 - f * s);\n    t = v * (1 - (1 - f) * s);\n    switch (i % 6) {\n      case 0: r = v, g = t, b = p; break;\n      case 1: r = q, g = v, b = p; break;\n      case 2: r = p, g = v, b = t; break;\n      case 3: r = p, g = q, b = v; break;\n      case 4: r = t, g = p, b = v; break;\n      case 5: r = v, g = p, b = q; break;\n    }\n    return {r: round(r * 255), g: round(g * 255), b: round(b * 255)};\n  },\n  \n  toHsv: function (rgb) {\n    // Modified from https://github.com/bgrins/TinyColor/blob/master/tinycolor.js#L446\n    var r = rgb.r / 255,\n        g = rgb.g / 255,\n        b = rgb.b / 255;\n    var max = Math.max(r, g, b),\n        min = Math.min(r, g, b),\n        delta = max - min;\n    var hue;\n    switch (max) {\n      case min:\n        hue = 0;\n        break;\n      case r:\n        hue = (g - b) / delta + (g < b ? 6 : 0);\n        break;\n      case g:\n        hue = (b - r) / delta + 2\n        break;\n      case b:\n        hue = (r - g) / delta + 4;\n        break;\n    }\n    hue /= 6;\n    return {\n      h: round(hue * 360),\n      s: round(max === 0 ? 0 : (delta / max) * 100),\n      v: round(max * 100)\n    };\n  }\n};\n\n\n\n// WEBPACK FOOTER //\n// ./colorModels/rgb.js","import hsl from \"colorModels/hsl\";\nimport rgb from \"colorModels/rgb\";\nimport hslString from \"colorModels/hslString\";\nimport rgbString from \"colorModels/rgbString\";\nimport hexString from \"colorModels/hexString\";\n\nconst colorModels = [\n  hsl,\n  rgb,\n  hslString,\n  rgbString,\n  hexString\n];\n\n/**\n  @constructor color object\n  @param {String} str (optional) CSS color string to use as the start color for this element\n*/\nlet color = function (str) {\n  if (!(this instanceof color)) return new color(str);\n  // The watch callback function for this color will be stored here\n  this._onChange = false;\n  // The default color value\n  this._value = {h: undefined, s: undefined, v: undefined};\n  this.register(\"hsv\", {\n    get: this.get,\n    set: this.set\n  });\n  // Loop through each external color model and register it\n  colorModels.forEach((model) => {\n    this.register(model.name, {\n      set: function (value) {\n        this.hsv = model.toHsv(value);\n      },\n      get: function () {\n        return model.fromHsv(this.hsv);\n      },\n    });\n  });\n  if (str) this.fromString(str);\n};\n\ncolor.prototype = {\n\n  /**\n    * @desc Register a new color model on this instance\n    * @param {String} name The name of the color model\n    * @param {Object} descriptor The property descriptor (see https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty#Description)\n  */\n  register: function (name, descriptor) {\n    Object.defineProperty(this, name, descriptor);\n  },\n\n  /**\n    * @desc Set a callback function that gets called whenever the selected color changes\n    * @param {Function} callback The watch callback\n    * @param {Boolean} callImmediately set to true if you want to call the callback as soon as it is added\n  */\n  watch: function (callback, callImmediately) {\n    this._onChange = callback;\n    if (callImmediately) this.forceUpdate();\n  },\n\n  /**\n    * @desc Remove the watch callback\n  */\n  unwatch: function () {\n    this.watch(false);\n  },\n\n  /**\n    * @desc Force an update\n  */\n  forceUpdate: function () {\n    var value = this._value;\n    this._onChange(value, value, {h: true, s: true, v: true});\n  },\n\n  /**\n    * @desc Set the color from a HSV value\n    * @param {Object} newValue - HSV object\n  */\n  set: function (newValue) {\n    // Loop through the channels and check if any of them have changed\n    var changes = {};\n    var oldValue = this._value;\n    for (var channel in oldValue) {\n      if (!newValue.hasOwnProperty(channel)) newValue[channel] = oldValue[channel];\n      changes[channel] = !(newValue[channel] == oldValue[channel]);\n    }\n    // Update the old value\n    this._value = newValue;\n    // If the value has changed, call hook callback\n    var callback = this._onChange;\n    if ((changes.h || changes.s || changes.v) && (\"function\" == typeof callback)) callback(newValue, oldValue, changes);\n  },\n\n  /**\n    * @desc Get the HSV value\n    * @return HSV object\n  */\n  get: function () {\n    return this._value;\n  },\n\n  /**\n    * @desc Set the color from a CSS string\n    * @param {String} str - HEX, rgb, or hsl color string\n  */\n  fromString: function (str) {\n    if (/^rgb/.test(str)) {\n      this.rgbString = str\n    }\n    else if (/^hsl/.test(str)) {\n      this.hslString = str;\n    }\n    else if (/^#[0-9A-Fa-f]/.test(str)) {\n      this.hexString = str;\n    }\n  }\n};\n\nmodule.exports = color;\n\n\n\n// WEBPACK FOOTER //\n// ./modules/color.js","import dom from \"util/dom\";\n\nconst doc = document;\n\n/**\n  @constructor stylesheet writer\n  @param {Object} overrides - an object representing the CSS rules that this stylesheet updates\n*/\nlet stylesheet = function (overrides) {\n  // Create a new style element\n  let style = dom.appendNew(doc.head, \"style\", {});\n  // Webkit apparently requires a text node to be inserted into the style element\n  // (according to https://davidwalsh.name/add-rules-stylesheets)\n  dom.append(style, doc.createTextNode(\"\"));\n  this.style = style;\n  // Create a reference to the style element's CSSStyleSheet object\n  // CSSStyleSheet API: https://developer.mozilla.org/en-US/docs/Web/API/CSSStyleSheet\n  let sheet = style.sheet;\n  this.sheet = sheet;\n  // Get a reference to the sheet's CSSRuleList object\n  // CSSRuleList API: https://developer.mozilla.org/en-US/docs/Web/API/CSSRuleList\n  this.rules = sheet.rules || sheet.cssRules;\n  // We'll store references to all the CSSStyleDeclaration objects that we change here, keyed by the CSS selector they belong to\n  // CSSStyleDeclaration API: https://developer.mozilla.org/en-US/docs/Web/API/CSSStyleDeclaration\n  this.map = {};\n};\n\nstylesheet.prototype = {\n\n  /**\n    * @desc Turns the stylesheet \"on\", allowing the styles to be rendered\n  */\n  on: function () {\n    this.enable();\n  },\n  enable: function () {\n    this.sheet.disabled = false;\n  },\n\n  /**\n    * @desc Turns the stylesheet \"off\", preventing the styles from being rendered\n  */\n  off: function () {\n    this.disable();\n  },\n  disable: function () {\n    this.sheet.disabled = true;\n  },\n\n  /**\n    * @desc Set a specific rule for a given selector\n    * @param {String} selector - the CSS selector for this rule (e.g. \"body\", \".class\", \"#id\")\n    * @param {String} property - the CSS property to set (e.g. \"background-color\", \"font-family\", \"z-index\")\n    * @param {String} value    - the new value for the rule (e.g. \"rgb(255, 255, 255)\", \"Helvetica\", \"99\")\n  */\n  setRule: function (selector, property, value) {\n    var sheet = this.sheet;\n    var rules = sheet.rules || sheet.cssRules;\n    var map = this.map;\n    // Convert property from camelCase to snake-case\n    property = property.replace(/([A-Z])/g, function($1) {\n      return \"-\" + $1.toLowerCase();\n    });\n    if (!map.hasOwnProperty(selector)){\n      // If the selector hasn't been used yet we want to insert the rule at the end of the CSSRuleList, so we use its length as the index value\n      var index = rules.length;\n      // Prepare the rule declaration text, since both insertRule and addRule take this format\n      var declaration = property + \": \" + value;\n      // Insert the new rule into the stylesheet\n      try {\n        // Some browsers only support insertRule, others only support addRule, so we have to use both\n        sheet.insertRule(selector + \" {\" + declaration + \";}\", index);\n      } catch(e) {\n        sheet.addRule(selector, declaration, index);\n      } finally {\n        // Because safari is perhaps the worst browser in all of history, we have to remind it to keep the sheet rules up-to-date\n        rules = sheet.rules || sheet.cssRules;\n        // Add our newly inserted rule's CSSStyleDeclaration object to the internal map\n        map[selector] = rules[index].style;\n      }\n    }\n    else {\n      map[selector].setProperty(property, value);\n    }\n  },\n\n  /**\n    * @desc Get an object representing the current css styles\n    * @return {Object} css object\n  */\n  getCss: function () {\n    var map = this.map;\n    var ret = {};\n    for (var selector in map) {\n      var ruleSet = map[selector];\n      ret[selector] = {};\n      for (var i = 0; i < ruleSet.length; i++) {\n        var property = ruleSet[i];\n        ret[selector][property] = ruleSet.getPropertyValue(property);\n      }\n    }\n    return ret;\n  },\n\n  /**\n    * @desc Get the stylesheet text\n    * @return {String} css text\n  */\n  getCssText: function () {\n    var map = this.map;\n    var ret = [];\n    for (var selector in map) {\n      ret.push(selector.replace(/,\\W/g, \",\\n\") + \" {\\n\\t\" + map[selector].cssText.replace(/;\\W/g, \";\\n\\t\") + \"\\n}\");\n    }\n    return ret.join(\"\\n\");\n  }\n};\n\nmodule.exports = stylesheet;\n\n\n\n// WEBPACK FOOTER //\n// ./modules/stylesheet.js","var round = Math.round;\n\nmodule.exports = {\n  name: \"hsl\",\n\n  fromHsv: function (hsv) {\n    var s = hsv.s / 100,\n        v = hsv.v / 100;\n    var p = (2 - s) * v;\n    s = s == 0 ? 0 : s * v / (p < 1 ? p : 2 - p);\n    return {\n      h: hsv.h,\n      s: round(s * 100),\n      l: round(p * 50)\n    };\n  },\n\n  toHsv: function (hsl) {\n    var s = hsl.s / 50,\n        l = hsl.l / 100;\n    s *= (l <= 1) ? l : 2 - l;\n    return {\n      h: hsl.h,\n      s: round(((2 * s) / (l + s)) * 100),\n      v: round((l + s) * 100)\n    };\n  }\n};\n\n\n\n// WEBPACK FOOTER //\n// ./colorModels/hsl.js","import hsl from \"colorModels/hsl\";\n\nmodule.exports = {\n  name: \"hslString\",\n\n  fromHsv: function (hsv) {\n    var color = hsl.fromHsv(hsv);\n    return \"hsl\" + (color.a ? \"a\" : \"\") + \"(\" + color.h + \", \" + color.s + \"%, \" + color.l + \"%\" + (color.a ? \", \" + color.a : \"\") + \")\";\n  },\n\n  toHsv: function (hslString) {\n    var parsed = hslString.match(/(hsla?)\\((\\d+)(?:\\D+?)(\\d+)(?:\\D+?)(\\d+)(?:\\D+?)?([0-9\\.]+?)?\\)/i);\n    return hsl.toHsv({\n      h: parseInt(parsed[2]),\n      s: parseInt(parsed[3]),\n      l: parseInt(parsed[4])\n    });\n  }\n};\n\n\n\n// WEBPACK FOOTER //\n// ./colorModels/hslString.js","function addColorStops(gradient, colorStops) {\n  for (stop in colorStops) {\n      gradient.addColorStop(stop, colorStops[stop]);\n  }\n  return gradient;\n};\n\nmodule.exports = {\n  linear: function (ctx, x1, y1, x2, y2, colorStops) {\n    return addColorStops(ctx.createLinearGradient(x1, y1, x2, y1), colorStops);\n  },\n  radial: function (ctx, x, y, min, max, colorStops) {\n    return addColorStops(ctx.createRadialGradient(x, y, min, x, y, max), colorStops);\n  }\n};\n\n\n\n// WEBPACK FOOTER //\n// ./ui/gradient.js","import dom from \"util/dom\";\n\n/**\n  * @constructor marker UI\n  * @param {Object} ctx - canvas 2d context to draw on\n  * @param {Object} opts - options\n*/\nlet marker = function (svg, opts) {\n  this._el = dom.appendNew(svg, \"g\", {}, \"SVG\");\n  [[5, \"#000\"], [2, \"#fff\"]].map((ring) => {\n    dom.appendNew(this._el, \"circle\", {\n      r: opts.r,\n      style: \"fill:none;stroke-width:\"+ ring[0] + \";stroke:\" + ring[1],\n      cy: 0,\n      cx: 0,\n    }, \"SVG\");\n  });\n};\n\nmarker.prototype = {\n  /**\n    * @desc move markerpoint to centerpoint (x, y) and redraw\n    * @param {Number} x - point x coordinate\n    * @param {Number} y - point y coordinate\n  */\n  move: function (x, y) {\n    dom.setAttr(this._el, {\n      transform: \"translate(\" + x + \" \" + y + \")\"\n    });\n  }\n};\n\nmodule.exports = marker;\n\n\n\n// WEBPACK FOOTER //\n// ./ui/marker.js","import wheel from \"ui/wheel\";\nimport slider from \"ui/slider\";\nimport dom from \"util/dom\";\n\nimport iroColor from \"modules/color\";\nimport iroStyleSheet from \"modules/stylesheet\";\n\n// When the user starts to interact with a color picker's UI, a referece to that coloPicker will be stored globally\nlet activeColorWheel = false;\n\n// Global mousemove + touchmove event handler\ndom.listen(document, [\"mousemove\", \"touchmove\"], function (e) {\n  // If there is an active colorWheel, call its mousemove handler\n  if (activeColorWheel) activeColorWheel._mouseMove(e);\n});\n\n// Global mouseup + touchend event handler\ndom.listen(document, [\"mouseup\", \"touchend\"], function (e) {\n  // If there is an active colorWheel, stop it from handling input and clear the active colorWheel reference\n  if (activeColorWheel) {\n    e.preventDefault();\n    activeColorWheel.emit(\"input:end\");\n    activeColorWheel._mouseTarget = false;\n    activeColorWheel = false;\n  }\n});\n\n/**\n  @constructor color wheel object\n  @param {ElementOrString} el - a DOM element or the CSS selector for a DOM element to use as a container for the UI\n  @param {Object} opts - options for this instance\n*/\nlet colorWheel = function (el, opts) {\n  if (!(this instanceof colorWheel)) return new colorWheel(el, opts);\n  // event storage for `on` and `off`\n  this._events = {};\n  this._mouseTarget = false;\n  this._onChange = false;\n  // Create an iroStyleSheet for this colorWheel's CSS overrides\n  this.stylesheet = new iroStyleSheet();\n  this.css = opts.css || opts.styles || undefined;\n  // Create an iroColor to store this colorWheel's selected color\n  this.color = new iroColor(opts.color || \"#fff\");\n\n  // Wait for the document to be ready, then init the UI\n  dom.whenReady(function () {\n    // If `el` is a string, use it to select an Element, else assume it's an element\n    el = (\"string\" == typeof el) ? dom.$(el) : el;\n    // Make sure the canvas wrapper is position:relative\n    // This is because we'll be using position:absolute to stack the canvas layers\n    el.style.cssText += \"position:relative\";\n    // Find the width and height for the UI\n    // If not defined in the options, try the HTML width + height attributes of the wrapper, else default to 320\n    var width = opts.width || parseInt(dom.attr(el, \"width\")) || 320;\n    var height = opts.height || parseInt(dom.attr(el, \"height\")) || 320;\n    // Create UI layers\n    // To support devices with hidpi screens, we scale the canvas so that it has more pixels, but still has the same size visually\n    // This implementation is based on https://www.html5rocks.com/en/tutorials/canvas/hidpi/\n    var pxRatio = devicePixelRatio || 1;\n    // Create a layer for each name\n    // Create a new canvas and add it to the page\n\n    var svg = dom.appendNew(el, \"svg\", {\n      viewBox: [0, 0, width, height].join(\" \"),\n      width: width,\n      height: height,\n      style: \"position:absolute;top:0;left:0;\"\n    }, \"SVG\");\n\n    var canvas = dom.appendNew(el, \"canvas\", {\n      width: width * pxRatio,\n      height: height * pxRatio,\n      style: \"width:\" + width + \"px;height:\" + height + \"px\"\n    });\n\n    var ctx = canvas.getContext(\"2d\");\n    ctx.scale(pxRatio, pxRatio);\n\n    this.el = el;\n    this.canvas = canvas;\n    this.ctx = ctx;\n    this.svg = svg;\n    // Calculate layout variables\n    var padding = opts.padding + 2 || 6,\n        borderWidth = opts.borderWidth || 0,\n        markerRadius = opts.markerRadius || 8,\n        sliderMargin = opts.sliderMargin || 24,\n        sliderHeight = opts.sliderHeight || (markerRadius * 2) + (padding * 2) + (borderWidth * 2),\n        bodyWidth = Math.min(height - sliderHeight - sliderMargin, width),\n        wheelRadius = (bodyWidth / 2) - borderWidth,\n        leftMargin = (width - bodyWidth) / 2;\n    var marker = {\n      r: markerRadius\n    };\n    var borderStyles = {\n      w: borderWidth,\n      color: opts.borderColor || \"#fff\",\n    };\n    // Create UI elements\n    this.ui = [\n      new wheel(ctx, svg, {\n        cX: leftMargin + (bodyWidth / 2),\n        cY: bodyWidth / 2,\n        r: wheelRadius,\n        rMax: wheelRadius - (markerRadius + padding),\n        marker: marker,\n        border: borderStyles\n      }),\n      new slider(ctx, svg, {\n        sliderType: \"v\",\n        x: leftMargin + borderWidth,\n        y: bodyWidth + sliderMargin,\n        w: bodyWidth - (borderWidth * 2),\n        h: sliderHeight - (borderWidth * 2),\n        r: (sliderHeight / 2) - borderWidth,\n        marker: marker,\n        border: borderStyles\n      })\n    ];\n    // Whenever the selected color changes, trigger a colorWheel update too\n    this.color.watch(this._update.bind(this), true);\n    // Add handler for mousedown + touchdown events on this element\n    dom.listen(el, [\"mousedown\", \"touchstart\"], this._mouseDown.bind(this));\n  }.bind(this));\n};\n\ncolorWheel.prototype = {\n  /**\n    * @desc Set a callback function that gets called whenever the selected color changes\n    * @param {Function} callback The watch callback\n    * @param {Boolean} callImmediately set to true if you want to call the callback as soon as it is added\n  */\n  watch: function (callback, callImmediately) {\n    this.on(\"color:change\", callback);\n    this._onChange = callback;\n    if (callImmediately) callback(this.color);\n  },\n\n  /**\n    * @desc Remove the watch callback\n  */\n  unwatch: function () {\n    this.off(\"color:change\", this._onChange);\n  },\n\n  /**\n    * @desc Set a callback function for an event\n    * @param {String} eventType The name of the event to listen to, pass \"*\" to listen to all events\n    * @param {Function} callback The watch callback\n  */\n  on: function (eventType, callback) {\n    var events = this._events;\n    (events[eventType] || (events[eventType] = [])).push(callback);\n  },\n\n  /**\n    * @desc Remove a callback function for an event added with on()\n    * @param {String} eventType The name of the event\n    * @param {Function} callback The watch callback to remove from the event\n  */\n  off: function (eventType, callback) {\n    var events = this._events;\n    if (events[eventType]) {\n      events[eventType].splice(events[eventType].indexOf(callback), 1);\n    }\n  },\n\n  /**\n    * @desc Emit an event\n    * @param {String} eventType The name of the event to emit\n    * @param {Object} data data to pass to all the callback functions\n  */\n  emit: function (eventType, data) {\n    var events = this._events;\n    (events[eventType] || []).map((callback) => { callback(data); });\n    (events[\"*\"] || []).map((callback) => { callback(data); });\n  },\n\n  /**\n    * @desc Get the local-space X and Y pointer position from an input event\n    * @param {Event} e A mouse or touch event\n    * @return {Object} x and y coordinates from the top-left of the UI\n    * @access protected\n  */\n  _getLocalPoint: function (e) {\n    // Prevent default event behaviour, like scrolling\n    e.preventDefault();\n    // Detect if the event is a touch event by checking if it has the `touches` property\n    // If it is a touch event, use the first touch input\n    var point = e.touches ? e.changedTouches[0] : e,\n        // Get the screen position of the UI\n        rect = this.canvas.getBoundingClientRect();\n    // Convert the screen-space pointer position to local-space\n    return {\n      x: point.clientX - rect.left,\n      y: point.clientY - rect.top\n    };\n  },\n\n  /**\n    * @desc Handle a pointer input at local-space point (x, y)\n    * @param {Event} e A mouse or touch event\n    * @return {Object} x and y coordinates from the top-left of the UI\n    * @access protected\n  */\n  _handleInput: function (x, y) {\n    // Use the active UI element to handle translating the input to a change in the color\n    this.color.set(this._mouseTarget.input(x, y));\n  },\n\n  /**\n    * @desc mousedown event handler\n    * @param {Event} e A mouse or touch event\n    * @access protected\n  */\n  _mouseDown: function (e) {\n    // Get the local-space position of the mouse input\n    var point = this._getLocalPoint(e),\n        x = point.x,\n        y = point.y;\n\n    // Loop through each UI element and check if the point \"hits\" it\n    this.ui.forEach((uiElement) => {\n      // If the element is hit, this means the user has clicked the element and is trying to interact with it\n      if (uiElement.checkHit(x, y)) {\n        // Set a reference to this colorWheel instance so that the global event handlers know about it\n        activeColorWheel = this;\n        // Set an internal reference to the uiElement being interacted with, for other internal event handlers\n        this._mouseTarget = uiElement;\n        // Emit input start event\n        this.emit(\"input:start\");\n        // Finally, use the position to update the picked color\n        this._handleInput(x, y);\n      }\n    });\n  },\n\n  /**\n    * @desc mousemose event handler\n    * @param {Event} e A mouse or touch event\n    * @access protected\n  */\n  _mouseMove: function (e) {\n    // If there is an active colorWheel (set in _mouseDown) then update the input as the user interacts with it\n    if (this == activeColorWheel) {\n      // Get the local-space position of the mouse input\n      var point = this._getLocalPoint(e);\n      // Use the position to update the picker color\n      this._handleInput(point.x, point.y);\n    }\n  },\n\n  /**\n    * @desc update the selected color\n    * @param {Object} newValue - the new HSV values\n    * @param {Object} oldValue - the old HSV values\n    * @param {Object} changes - booleans for each HSV channel: true if the new value is different to the old value, else false\n    * @access protected\n  */\n  _update: function (newValue, oldValue, changes) {\n    var color = this.color;\n    var rgb = color.rgbString;\n    var css = this.css;\n    // Loop through each UI element and update it\n    this.ui.forEach(function (uiElement) {\n      uiElement.update(color, changes);\n    });\n    // Update the stylesheet too\n    for (var selector in css) {\n      var properties = css[selector];\n      for (var prop in properties) {\n        this.stylesheet.setRule(selector, prop, rgb);\n      }\n    }\n    // Call the color change event\n    this.emit(\"color:change\", color);\n  },\n};\n\nmodule.exports = colorWheel;\n\n\n\n// WEBPACK FOOTER //\n// ./modules/colorPicker.js","import rgb from \"colorModels/rgb\";\n\nmodule.exports = {\n  name: \"hexString\",\n\n  fromHsv: function (hsv) {\n    var color = rgb.fromHsv(hsv),\n        r = color.r,\n        g = color.g,\n        b = color.b;\n    // If each RGB channel's value is a multiple of 17, we can use HEX shorthand notation\n    var useShorthand = (r % 17 == 0) && (g % 17 == 0) && (b % 17 == 0),\n        // If we're using shorthand notation, divide each channel by 17\n        divider      = useShorthand ? 17 : 1,\n        // bitLength of each channel (for example, F is 4 bits long while FF is 8 bits long)\n        bitLength    = useShorthand ? 4 : 8,\n        // Target length of the string (ie \"#FFF\" or \"#FFFFFF\")\n        strLength    = useShorthand ? 4 : 7,\n        // Combine the channels together into a single integer\n        int          = (r / divider) << (bitLength * 2) | (g / divider) << bitLength | (b / divider),\n        // Convert that integer to a hex string\n        str          = int.toString(16);\n    // Add right amount of left-padding\n    return \"#\" + (new Array(strLength - str.length).join(\"0\")) + str;\n  },\n\n  toHsv: function (hex) {\n    // Strip any \"#\" characters\n    hex = hex.replace(/#/g, '');\n    // Prefix the hex string with \"0x\" which indicates a number in hex notation, then convert to an integer\n    var int         = parseInt(\"0x\" + hex),\n        // If the length of the input is only 3, then it is a shorthand hex color\n        isShorthand = hex.length == 3,\n        // bitMask for isolating each channel\n        bitMask     = isShorthand ? 0xF : 0xFF,\n        // bitLength of each channel (for example, F is 4 bits long while FF is 8 bits long)\n        bitLength   = isShorthand ? 4 : 8,\n        // If we're using shorthand notation, multiply each channel by 17\n        multiplier  = isShorthand ? 17 : 1;\n\n    return rgb.toHsv({\n      r: ((int >> (bitLength * 2)) & bitMask) * multiplier,\n      g: ((int >> bitLength) & bitMask) * multiplier,\n      b: (int & bitMask) * multiplier,\n    });\n  }\n};\n\n\n\n// WEBPACK FOOTER //\n// ./colorModels/hexString.js","import rgb from \"colorModels/rgb\";\n\nmodule.exports = {\n  name: \"rgbString\",\n\n  fromHsv: function (hsv) {\n    var color = rgb.fromHsv(hsv);\n    return \"rgb\" + (color.a ? \"a\" : \"\") + \"(\" + color.r + \", \" + color.g + \", \" + color.b + (color.a ? \", \" + color.a : \"\") + \")\";\n  },\n\n  toHsv: function (rgbString) {\n    var parsed = rgbString.match(/(rgba?)\\((\\d+)(?:\\D+?)(\\d+)(?:\\D+?)(\\d+)(?:\\D+?)?([0-9\\.]+?)?\\)/i);\n    return rgb.toHsv({\n      r: parseInt(parsed[2]),\n      g: parseInt(parsed[3]),\n      b: parseInt(parsed[4])\n    });\n  }\n};\n\n\n\n// WEBPACK FOOTER //\n// ./colorModels/rgbString.js","import colorPicker from \"modules/colorPicker\";\nimport color from \"modules/color\";\nimport stylesheet from \"modules/stylesheet\";\n\nmodule.exports = {\n  Color: color,\n  ColorPicker: colorPicker,\n  Stylesheet: stylesheet,\n  // for backwards compat\n  ColorWheel: colorPicker,\n};\n\n\n\n// WEBPACK FOOTER //\n// ./iro.js","import gradient from \"ui/gradient\";\nimport marker from \"ui/marker\";\nimport dom from \"util/dom\";\nimport hslString from \"colorModels/hslString\";\n\n/**\n  * @constructor slider UI\n*/\nlet slider = function (ctx, svg, opts) {\n  this._ctx = ctx;\n  opts.x1 = opts.x;\n  opts.y1 = opts.y;\n  opts.x2 = opts.x + opts.w;\n  opts.y2 = opts.y + opts.h;\n  // \"range\" limits how far the slider's marker can travel, and where it stops and starts along the X axis\n  opts.range = {\n    min: opts.x + opts.r,\n    max: opts.x2 - opts.r,\n    w: opts.w - (opts.r * 2)\n  };\n  opts.sliderType = opts.sliderType || \"v\";\n  this.type = \"slider\";\n  this.marker = new marker(svg, opts.marker);\n  this._opts = opts;\n  var borderWidth = opts.border.w;\n  var radius = opts.r + borderWidth / 2;\n  if (borderWidth > 0) {\n    dom.appendNew(svg, \"rect\", {\n      rx: radius,\n      ry: radius,\n      x: opts.x - borderWidth / 2,\n      y: opts.y - borderWidth / 2,\n      width: opts.w + borderWidth,\n      height: opts.h + borderWidth,\n      style: \"fill:none;stroke-width:\"+ borderWidth + \";stroke:\" + opts.border.color,\n    }, \"SVG\");\n  }\n};\n\nslider.prototype = {\n  /**\n    * @desc redraw this UI element\n  */\n  draw: function (hsv) {\n    var ctx = this._ctx;\n    var opts = this._opts;\n    var x1 = opts.x1,\n        y1 = opts.y1,\n        x2 = opts.x2,\n        y2 = opts.y2,\n        w = opts.w,\n        h = opts.h,\n        r = opts.r;\n\n    // Clear the existing UI\n    ctx.clearRect(x1, y1, w, h);\n\n    // Draw a rounded rect\n    // Modified from http://stackoverflow.com/a/7838871\n    ctx.beginPath();\n    ctx.moveTo(x1 + r, y1);\n    ctx.arcTo(x2, y1, x2, y2, r);\n    ctx.arcTo(x2, y2, x1, y2, r);\n    ctx.arcTo(x1, y2, x1, y1, r);\n    ctx.arcTo(x1, y1, x2, y1, r);\n    ctx.closePath();\n\n    // I plan to have different slider \"types\" in the future\n    // (I'd like to add a transparency slider at some point, for example)\n    var fill;\n\n    // For now the only type is \"V\", meaning this slider adjusts the HSV V channel\n    if (opts.sliderType == \"v\") {\n      fill = gradient.linear(ctx, x1, y1, x2, y2, {\n        0: \"#000\",\n        1: hslString.fromHsv({h: hsv.h, s: hsv.s, v: 100}),\n      });\n    }\n\n    // Draw gradient\n    ctx.fillStyle = fill;\n    ctx.fill();\n  },\n\n  /**\n    * @desc updates this element to represent a new color value\n    * @param {Object} color - an iroColor object with the new color value\n    * @param {Object} changes - an object that gives a boolean for each HSV channel, indicating whether ot not that channel has changed\n  */\n  update: function (color, changes) {\n    var opts = this._opts;\n    var range = opts.range;\n    var hsv = color.hsv;\n    if (opts.sliderType == \"v\") {\n      if (changes.h || changes.s) {\n        this.draw(hsv);\n      }\n      if (changes.v) {\n        var percent = (hsv.v / 100);\n        this.marker.move(range.min + (percent * range.w), opts.y1 + (opts.h / 2));\n      }\n    }\n  },\n\n  /**\n    * @desc Takes a point at (x, y) and returns HSV values based on this input -- use this to update a color from mouse input\n    * @param {Number} x - point x coordinate\n    * @param {Number} y - point y coordinate\n    * @return {Object} - new HSV color values (some channels may be missing)\n  */\n  input: function (x, y) {\n    var opts = this._opts;\n    var range = opts.range;\n    var dist = Math.max(Math.min(x, range.max), range.min) - range.min;\n    return {\n      v: Math.round((100 / range.w) * dist),\n    };\n  },\n\n  /**\n    * @desc Check if a point at (x, y) is inside this element\n    * @param {Number} x - point x coordinate\n    * @param {Number} y - point y coordinate\n    * @return {Boolean} - true if the point is a \"hit\", else false\n  */\n  checkHit: function (x, y) {\n    var opts = this._opts;\n    return (x > opts.x1) && (x < opts.x2) && (y > opts.y1) && (y < opts.y2);\n  }\n};\n\nmodule.exports = slider;\n\n\n\n// WEBPACK FOOTER //\n// ./ui/slider.js","import gradient from \"ui/gradient\";\nimport marker from \"ui/marker\";\nimport dom from \"util/dom\";\n\n// Quick references to reused math functions\nvar PI = Math.PI,\n    pow = Math.pow,\n    sqrt = Math.sqrt,\n    abs = Math.abs,\n    round = Math.round;\n\n/**\n  * @constructor hue wheel UI\n*/\nlet wheel = function (ctx, svg, opts) {\n  this._ctx = ctx;\n  this._opts = opts;\n  this.type = \"wheel\";\n  this.marker = new marker(svg, opts.marker);\n  if (borderWidth > 0) {\n    dom.appendNew(svg, \"circle\", {\n      r: opts.r + opts.border.w / 2,\n      style: \"fill:none;stroke-width:\"+ opts.border.w + \";stroke:\" + opts.border.color,\n      cy: opts.cY,\n      cx: opts.cX,\n    }, \"SVG\");\n  }\n};\n\nwheel.prototype = {\n\n  /**\n    * @desc redraw this UI element\n    * @param {Number} value - The hsv value component to use when drawing\n  */\n  draw: function (value) {\n    var ctx = this._ctx;\n    var opts = this._opts;\n    var x = opts.cX,\n        y = opts.cY,\n        border = opts.border,\n        borderWidth = border.w,\n        radius = opts.r;\n\n    // Clear the area where the wheel will be drawn\n    ctx.clearRect((x - radius) - borderWidth, (y - radius) - borderWidth, radius * 2, radius * 2);\n    ctx.lineWidth = radius;\n\n    // The hue wheel is basically drawn with a series of thin \"pie slices\" - one slice for each hue degree\n    // Here we calculate the angle for each slice, in radians\n    var sliceAngle = (2 * PI) / 360;\n\n    // Create a loop to draw each slice\n    for (var hue = 0, sliceStart = 0; hue < 360; hue++, sliceStart += sliceAngle) {\n      // Create a HSL color for the slice using the current hue value\n      ctx.strokeStyle = \"hsl(\" + hue + \",100%,\" + (value / 2) + \"%)\";\n      ctx.beginPath();\n      // For whatever reason (maybe a rounding issue?) the slices had a slight gap between them, which caused rendering artifacts\n      // So we make them overlap ever so slightly by adding a tiny value to the slice angle\n      ctx.arc(x, y, radius / 2, sliceStart, sliceStart + sliceAngle + 0.04);\n      ctx.stroke();\n    }\n\n    // Create a radial gradient for \"saturation\"\n    var hslString = \"hsla(0,0%,\" + value + \"%,\";\n    ctx.fillStyle = gradient.radial(ctx, x, y, 0, opts.rMax, {\n      // The center of the color wheel should be pure white (0% saturation)\n      0: hslString + \"1)\",\n      // It gradially tapers to transparent white (or, visually, 100% saturation color already drawn) at the edge of the wheel\n      1: hslString + \"0)\",\n    });\n    // Draw a rect using the gradient as a fill style\n    ctx.fillRect(x - radius, y - radius, radius * 2, radius * 2);\n  },\n\n  /**\n    * @desc updates this element to represent a new color value\n    * @param {Object} color - an iroColor object with the new color value\n    * @param {Object} changes - an object that gives a boolean for each HSV channel, indicating whether ot not that channel has changed\n  */\n  update: function (color, changes) {\n    var opts = this._opts;\n    var hsv = color.hsv;\n    // If the V channel has changed, redraw the wheel UI with the new value\n    if (changes.v) {\n      this.draw(hsv.v);\n    }\n    // If the H or S channel has changed, move the marker to the right position\n    if (changes.h || changes.s) {\n      // convert the hue value to radians, since we'll use it as an angle\n      var hueAngle = hsv.h * (PI/180);\n      // convert the saturation value to a distance between the center of the ring and the edge\n      var dist = (hsv.s / 100) * opts.rMax;\n      // Move the marker based on the angle and distance\n      this.marker.move(opts.cX + dist * Math.cos(hueAngle), opts.cY + dist * Math.sin(hueAngle));\n    }\n  },\n\n  /**\n    * @desc Takes a point at (x, y) and returns HSV values based on this input -- use this to update a color from mouse input\n    * @param {Number} x - point x coordinate\n    * @param {Number} y - point y coordinate\n    * @return {Object} - new HSV color values (some channels may be missing)\n  */\n  input: function (x, y) {\n    var opts = this._opts,\n        cX = opts.cX,\n        cY = opts.cY,\n        radius = opts.r,\n        rangeMax = opts.rMax;\n\n    // Angle in radians, anticlockwise starting at 12 o'clock\n    var angle = Math.atan2(x - cX, y - cY),\n        // Calculate the hue by converting the angle to radians, and normalising the angle to 3 o'clock\n        hue = 360 - (round(angle * (180 / PI)) + 270) % 360,\n        // Find the point's distance from the center of the wheel\n        // This is used to show the saturation level\n        dist = Math.min(sqrt(pow(cX - x, 2) + pow(cY - y, 2)), rangeMax);\n\n    // Return just the H and S channels, the wheel element doesn't do anything with the L channel\n    return {\n      h: hue,\n      s: round((100 / rangeMax) * dist)\n    };\n  },\n\n  /**\n    * @desc Check if a point at (x, y) is inside this element\n    * @param {Number} x - point x coordinate\n    * @param {Number} y - point y coordinate\n    * @return {Boolean} - true if the point is a \"hit\", else false\n  */\n  checkHit: function (x, y) {\n    var opts = this._opts;\n\n    // Check if the point is within the hue ring by comparing the point's distance from the centre to the ring's radius\n    // If the distance is smaller than the radius, then we have a hit\n    var dx = abs(x - opts.cX),\n        dy = abs(y - opts.cY);\n    return sqrt(dx * dx + dy * dy) < opts.r;\n  }\n};\n\nmodule.exports = wheel;\n\n\n\n// WEBPACK FOOTER //\n// ./ui/wheel.js"],"sourceRoot":""}